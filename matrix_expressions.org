* Introduction 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
A <- matrix(1, nrow = 400, ncol = 300)
B <- matrix(1, nrow = 300, ncol = 30)
C <- matrix(1, nrow = 30, ncol = 500)
D <- matrix(1, nrow = 500, ncol = 400)

library(microbenchmark)

res <- microbenchmark(A %*% B %*% C %*% D, ((A %*% B) %*% C) %*% D, (A %*% (B %*% C)) %*% D, (A %*% B) %*% (C %*% D), A %*% (B %*% (C %*% D)), A %*% ((B %*% C) %*% D))

options(microbenchmark.unit = "relative")
print(res, signif = 3, order = "mean")
#+END_SRC

The approach we take in chapter 2 is to delay the evaluation of matrix multiplication and instead build a data structure for matrix expressions, one we can evaluate later when we have the entire matrix multiplication expression constructed. It is a simple domain specific language, but it contains all the components we typically need in one: we need code for parsing an expression and creating a representation of it, we need to do some manipulation of expressions, and we need to evaluate them. 

For parsing expressions, we need to capture matrixes and multiplications. We wrap matrices in a class to make them objects of our language, rather than plain R data: 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
# overload multiplication operator
m <- function(data) {
    structure(data,
              nrow = nrow(data),
              ncol = ncol(data),
              class = c("matrix_expr", class(data)))
}

# save references to matrices we want to multiply together
matrix_mult <- function(A, B) {
    structure(list(left = A, right = B),
              nrow = nrow(A),
              ncol = ncol(B),
              class = c("matrix_mult", "matrix_expr"))
}

`*.matrix_expr` <- function(A, B) {
    matrix_mult(A, B)
}

# syntactic sugar for A %*% B %*% C %*% D
# this constructs a data structure representation, but doesn't eval
m(A) * m(B) * m(C) * m(D)
list(A, B, C, D) %>% reduce(., ~ m(.x))

# eval mmult
v <- function(expr) eval_matrix_expr(rearrange_matrix_expr(expr))
#+END_SRC

* Matrix Expressions 

Our goal for writing a language for matrix expressions is to improve upon the default performance of the built-in matrix expressions. We achieve this by taking a more global view of expressions than R does. R handles each operator one at a time from left to right, but we will analyze expressions and rearrange them to improve performance. These are the steps we must take to do this: 

1. parse expressions into data that we can manipulate
2. rearrange the expressions into more efficient expressions
3. provide a way to evaluate the expressions 

** Parsing Expressions 

To keep things simple, we only consider matrix multiplication and matrix addition. We do not include scalar multiplication or inverting or transposing matrices. 

With these restrictions, we can say that a matrix expression is either just a matrix, the product of two matrix expressions, or the sum of two matrix expressions. We represent this as a class hierarchy with one abstract superclass for expressions, and three concrete classes representing data, products, and sums. 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
# constructors
m <- function(data) {
    structure(list(data = data),
              nrow = nrow(data),
              ncol = ncol(data),
              # for pretty printing
              def_expr = deparse(substitute(data)),
              class = c("matrix_data", "matrix_expr"))
}

matrix_mult <- function(A, B) {
    structure(list(left = A,
                   right = B),
              nrow = nrow(A),
              ncol = ncol(B),
              class = c("matrix_mult", "matrix_expr"))
}

matrix_sum <- function(A, B) {
    structure(list(left = A,
                   right = B),
              nrow = nrow(A),
              ncol = ncol(B),
              class = c("matrix_sum", "matrix_expr"))
}

# helper functions for matrix expressions for pretty printing
toString.matrix_data <- function(x, ...) {
    paste0("[", attr(x, "def_expr"), "]")
}

toString.matrix_mult <- function(x, ...) {
    paste0("(", toString(x$left), " * ", toString(x$right), ")")
}

toString.matrix_sum <- function(x, ...) {
    paste0("(", toString(x$left), " + ", toString(x$right), ")")
}

print.matrix_expr <- function(x, ...) {
    cat(toString(x), "\n")
}

# try constructing a small expression
A <- matrix(1, nrow = 10, ncol = 20)
B <- matrix(1, nrow = 20, ncol = 10)
C <- matrix(1, nrow = 10, ncol = 10)

matrix_sum(matrix_mult(m(A), m(B)), m(C))

# overload the multiplication and addition operators for mat_exprs
`*.matrix_expr` <- function(A, B) {
    stopifnot(ncol(A) == nrow(B))
    matrix_mult(A, B)
}

`+.matrix_expr` <- function(A, B) {
    stopifnot(dim(A) == dim(B))
    matrix_sum(A, B)
}

m(A) * m(B) + m(C)

# use dim function for the addition operator 
dim.matrix_expr <- function(x) {
    c(attr(x, "nrow"),
      attr(x, "ncol"))
}
#+END_SRC

** Meta-Programming Parsing 

